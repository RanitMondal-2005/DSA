# METHOD 1
# undirected graph
n=5 # no of nodes
edges=[(0,1,9),(0,2,75),(1,2,95),(1,3,19),(1,4,42),(2,3,51),(2,4,66),(3,4,31)]
adj_matrix=[[0]*n for _ in range(n)]
for u,v,w in edges:
    adj_matrix[u][v]=w
    adj_matrix[v][u]=w
for i in range(n):
    print(i,'->',adj_matrix[i])
# Prim's Algorithm : using Loop + adjmatrix
visited=[False]*n
# u can start from any vertex, here st from node 0
visited[0]=True
ans=0
for _ in range(n-1): # n-1 edges needed
    x=-1
    y=-1
    # initially take minimum edge weight as infinity
    mn=float('inf')
    # traverse through every pair in graph,where:
    for i in range(n): # i should be visited (i is inside mst)
        for j in range(n): # j should not be visited( j is outside mst)
            # also check if there is an edge btw i and j
            if adj_matrix[i][j]!=0 and visited[i] and not visited[j]:
                # if curr min less than prev min then, take that min weight and add
                if adj_matrix[i][j]<mn:
                    mn=adj_matrix[i][j]
                    x=i
                    y=j
    # mark j as visited
    ans+=mn
    visited[y]=True

print("The minimum weight of the MST is: ", ans)    # # output is 110



# METHOD 2
import heapq
n=5 # no of nodes
edges=[(0,1,9),(0,2,75),(1,2,95),(1,3,19),(1,4,42),(2,3,51),(2,4,66),(3,4,31)]
adj_list=[[] for _ in range(n)]
for u,v,w in edges:
    adj_list[u].append((v,w))
    adj_list[v].append((u,w))
for i in range(n):
    print(i,'->',adj_list[i])
# Prim's Algorithm : using Priority Queue(heap) + adjList
heap=[]
ans=0 # total weight of all min edges
visited=[False]*n
# let source node be 0 and cost(weight) of source node be also 0
heapq.heappush(heap,(0,0)) # push weight and node in heap

# loop until heap is empty( all vertex are processed)
while len(heap)>0:
    weight,u=heapq.heappop(heap)
    if visited[u]:
        continue
    visited[u]=True
    ans+=weight
    for v,w in adj_list[u]:
        if not visited[v]:
            heapq.heappush(heap, (w, v))

print(ans) ## output is 110








