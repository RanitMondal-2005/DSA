# Binary Knapsack
# Solution Using DP(recursion)
def knapsack(i,n,values,weights,W):
    # i is the starting index ( of current item)
    # base case
    if i==n: # if all items are visited
        return 0
    # Logic is : Consider every items (Both Take & Not take case)
    take=0
    if weights[i]<=W: # if value of that item is less than the max capacity of knapsack then only we can take that item
        take=values[i]+knapsack(i+1,n,values,weights,W-weights[i])
    not_take=knapsack(i+1,n,values,weights,W)
    return max(take,not_take)
n=5 # no of items
values=[10,5,8,5,6]
weights=[3,2,4,6,4]
W=6 # maximum capacity of Knapsack(bag)
ans=knapsack(0,n,values,weights,W)
print("Maximum Profit : ",ans)


# Unbound Knapsack
