# METHOD 1: Using DFS

n=5 # no of nodes
edges=[(0,1,9),(0,2,75),(1,2,95),(1,3,19),(1,4,42),(2,3,51),(2,4,66),(3,4,31)]
# kruskal's Algorithm using DFS
# step 1: sort edges by weight
edges.sort(key=lambda x:x[2])
# step 2 : initialize variables
mst_edges=[] # to see which edges formed the mst
mst_adj=[[] for _ in range(n)] # MST adj list, for selected edges
ans=0 # total min edge weight 
# step 3 :  DFS to check if v is reachable from u
def dfs(i,target,visited): # i is curr node
    # this is not typical cycle detection in a graph,, this logic will be valid for both directed/undirected graphs 
    if i==target:
        return True # cycle formed as path exit 
    visited[i]=True
    # look for neighbor of v
    for x in mst_adj[i]:
        if not visited[x]:
            if dfs(x,target,visited):
                return True
    return False
    

# step 4 : Iterate over edges
for u,v,w in edges:
    visited=[False]*n
    if dfs(u,v,visited):
        # cycle detected , skip that edge
        continue
    # if no cycle detected, then safe to add that edge
    mst_adj[u].append(v)
    mst_adj[v].append(u)
    ans+=w
    mst_edges.append((u,v,w))

print("Total min edge weight:",ans)
print("MST edges=",mst_edges)


